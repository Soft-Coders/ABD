create or replace PACKAGE PK_OPERATIVA AS 
    
    PROCEDURE INSERTAR_TRANSACCIONES(
--  P_ID                    ASIGNADA SQ_TRANSACCION EN RUNTIME
    P_FECHA_INSTRUCCION     IN TRANSACCION.FECHA_INSTRUCCION%TYPE, -- IF NULL -> SYSDATE
    P_CANTIDAD              IN TRANSACCION.CANTIDAD%TYPE, -- IF <= 0 -> EXCEPTION
--  P_FECHA_EJECUCION       ASIGNADA EN RUNTIME
    P_TIPO                  IN TRANSACCION.TIPO%TYPE, -- NO CONTROLADO
    P_COMISION              IN TRANSACCION.COMISION%TYPE, -- IF < 0 -> EXCEPTION
    P_INTERNACIONAL         IN TRANSACCION.INTERNACIONAL%TYPE, -- IF NULL -> EXCEPTION
    P_DIVISA_ABREVIATURA    IN DIVISA.ABREVIATURA%TYPE, -- IF NOT FOUND -> EXCEPTION
    P_DIVISA_ABREVIATURA2   IN DIVISA.ABREVIATURA%TYPE, -- IF NOT FOUND -> EXCEPTION
    IBAN_1                  IN CUENTA.IBAN%TYPE, -- MAYBE FINTECH, REFERENCIA OR CUENTA (BARE)
    IBAN_2                  IN CUENTA.IBAN%TYPE  -- MAYBE FINTECH, REFERENCIA OR CUENTA (BARE)
    )
    IS -- VARIABLES
    DIVISA_1 DIVISA.ABREVIATURA%TYPE;
    DIVISA_2 DIVISA.ABREVIATURA%TYPE;
    CUENTA_1 CUENTA.CUENTA_ID%TYPE;
    CUENTA_2 CUENTA.CUENTA_ID%TYPE;
    FINTECH  CUENTA.CUENTA_ID%TYPE;
    P_SALDO  SEGREGADA.SALDO%TYPE;
    DIVISA_R CUENTA_REFERENCIA.DIVISA_ABREVIATURA%TYPE;
    CAMBIO_1 DIVISA.CAMBIO_EURO%TYPE;
    CAMBIO_2 DIVISA.CAMBIO_EURO%TYPE;
    IMPORTE  TRANSACCION.CANTIDAD%TYPE;
    REF_AUX  CUENTA_REFERENCIA.CUENTA_CUENTA_ID%TYPE;
    BEGIN
        IF P_FECHA_INSTRUCCION IS NULL THEN
            P_FECHA_INSTRUCCION := SYSDATE;
        END IF;
        IF P_CANTIDAD <= 0 THEN
            RAISE CANTIDAD_INVALIDA_EXCEPTION;
        END IF;
        IF P_COMISION < 0 THEN
            RAISE COMISION_INVALIDA_EXCEPTION;
        END IF;
        IF P_INTERNACIONAL IS NULL THEN
            RAISE NULL_INTERNACIONAL_EXCEPTION;
        END IF;

        -- FIND DIVISAS DE TRANSACCIÃ“N
        SELECT ABREVIATURA INTO DIVISA_1 FROM DIVISA WHERE ABREVIATURA LIKE P_DIVISA_ABREVIATURA;
        SELECT ABREVIATURA INTO DIVISA_2 FROM DIVISA WHERE ABREVIATURA LIKE P_DIVISA_ABREVIATURA2;
        IF DIVISA_1 IS NULL OR DIVISA_2 IS NULL THEN
            RAISE DIVISA_NOT_FOUND_EXCEPTION;
        END IF;

        -- FIND CUENTAS
        SELECT CUENTA_ID INTO CUENTA_1 FROM CUENTA WHERE IBAN LIKE IBAN_1 FOR UPDATE; -- NO SE PERMITE INSERTAR O ELIMINAR LA CUENTA DURANTE TRANSACCIÃ“N
        SELECT CUENTA_ID INTO CUENTA_2 FROM CUENTA WHERE IBAN LIKE IBAN_2 FOR UPDATE; -- NO SE PERMITE INSERTAR O ELIMINAR LA CUENTA DURANTE TRANSACCIÃ“N

        -- SI AMBAS CUENTAS NO SE ENCUENTRAN EN LA BD, LA TRANSACCIÃ“N ES INVÃ?LIDA
        IF CUENTA_1 IS NULL AND CUENTA_2 IS NULL THEN
            RAISE CUENTAS_NO_EXISTEN_EXCEPTION;
        END IF;
        
        -- SE CONVIERTE A LA DIVISA DE LA CUENTA
        SELECT CAMBIO_EURO INTO CAMBIO_1 FROM DIVISA WHERE ABREVIATURA = P_DIVISA_ABREVIATURA FOR UPDATE; -- NO SE PERMITE ACTUALIZAR EL CAMBIO DURANTE TRANSSACCIÃ“N
        SELECT CAMBIO_EURO INTO CAMBIO_2 FROM DIVISA WHERE ABREVIATURA = P_DIVISA_ABREVIATURA2 FOR UPDATE;-- NO SE PERMITE ACTUALIZAR EL CAMBIO DURANTE TRANSSACCIÃ“N
        IMPORTE := (P_CANTIDAD * CAMBIO_1) / CAMBIO_2;

        -- SI ALGUNA DE ELLAS NO SE ENCUNTRA EN LA BD, SE TOMA COMO EXTERNA Y
        -- SE CREA UNA CUENTA CON ESTE IBAN COMO REFERENCIA A UNA CUENTA EXTERNA
        IF CUENTA_1 IS NULL THEN -- CUENTA_1 ESTÃ? REGISTRADA
            -- SE COMPRUEBA QUE LA OTRA CUENTA SEA FINTECH
            -- NO ES NECESARIO BLOQUEAR LAS CUENTAS FINTECH, SEGREGADAS O POOLED YA QUE CUENTA ESTÃ? BLOQUEADA
            SELECT CUENTA_CUENTA_ID INTO CUENTA_2 FROM CUENTA_FINTECH WHERE CUENTA_CUENTA_ID = CUENTA_2;
            IF CUENTA_2 IS NULL THEN
                RAISE NO_CUENTA_FINTECH_EXCEPTION;
            END IF;
            
            -- SE COMPRUEBA QUE SEA SEGREGADA O POOLED
            SELECT CUENTA_FINTECH_ID INTO FINTECH FROM POOLED_ACCOUNT WHERE CUENTA_FINTECH_ID = CUENTA_2;
            IF FINTECH IS NULL THEN

                SELECT CUENTA_FINTECH_ID INTO FINTECH FROM SEGREGADA WHERE CUENTA_FINTECH_ID = CUENTA_2;
                IF FINTECH IS NULL THEN -- NO ES NI POOLED NI SEGREGADA -> EXCEPTION
                    RAISE NO_CUENTA_FINTECH_EXCEPTION;
                ELSE -- LA CUENTA FINTECH ES SEGREGADA

                    -- SE COMPRUEBA QUE LAS DIVISAS COINCIDAN Y SE GUARDA ID DE CUENTA_REFERENCIA
                    -- SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                    -- JOIN SEGREGADA S ON S.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                    -- WHERE S.CUENTA_FINTECH_ID = FINTECH;
                    
                    SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX
                    FROM CUENTA_REFERENCIA CR, SEGREGADA S
                    WHERE CR.CUENTA_CUENTA_ID (+) = S.CUENTA_FINTECH_ID AND S.CUENTA_FINTECH_ID = FINTECH
                    FOR UPDATE;

                    IF DIVISA_R <> P_DIVISA_ABREVIATURA2 THEN -- DIVISAS NO COINCIDEN -> EXCEPTION
                        RAISE SEGREGADA_DIVISA_NOT_MATCH;
                    END IF;

                    -- AUMENTAR SALDO
                    UPDATE CUENTA_REFERENCIA SET SALDO = SALDO + IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                END IF;
            ELSE -- LA CUENTA FINTECH ES POOLED

                -- SE BUSCA LA DIVISA DESEADA EN LA POOLED, SI NO SE ENCUENTRA SE CREA
                SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                JOIN DEPOSITAR_EN D ON D.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                JOIN POOLED_ACCOUNT P ON P.CUENTA_FINTECH_ID = D.POOL_ID
                WHERE P.CUENTA_FINTECH_ID = FINTECH
                AND CR.DIVISA_ABREVIATURA LIKE P_DIVISA_ABREVIATURA2
                FOR UPDATE;

                IF DIVISA_R IS NULL OR REF_AUX IS NULL THEN -- DIVISA NOT FOUND -> CREAR CUENTA_REF CON DIVISA
                    REF_AUX := SQ_CUENTA.NEXTVAL;
                    -- ID BY SEQUENCE, BANCO: DEFAULT, SALDO INICIADO CON CANTIDAD DE TRANSACCION
                    INSERT INTO CUENTA_REFERENCIA VALUES (REF_AUX, 'DEFAULT', NULL, NULL, IMPORTE, SYSDATE, 'ACTIVO', P_DIVISA_ABREVIATURA2);
                    -- SE ASIGNA A LA CUENTA POOLED LA NUEVA CUENTA REFERENCIA CON EL SALDO DE LA TRANSACCION
                    INSERT INTO DEPOSITAR_EN VALUES (IMPORTE, REF_AUX, FINTECH);
                ELSE -- CUENTA POOLED YA TIENE REF CON DIVISA DESEADA
                    -- AGREGAR TRANSACCION A SALDO
                    UPDATE CUENTA_REFERENCIA SET SALDO = SALDO + IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                    UPDATE DEPOSITAR_EN SET SALDO = SALDO + IMPORTE WHERE CUENTA_REF_ID = REF_AUX AND POOL_ID = FINTECH;
                END IF;

            END IF;

            -- CREAR CUENTA EXTERNA NO REGISTRADA
            CUENTA_1 := SQ_CUENTA.NEXTVAL;
            INSERT INTO CUENTA VALUES (CUENTA_1, IBAN_1, NULL); -- ID BY SEQUENCE SWIFT IS NULL
                
        ELSIF CUENTA_2 IS NULL THEN -- CUENTA_2 NO ESTÃ? REGISTRADA

            -- SE COMPRUEBA QUE LA OTRA CUENTA SEA FINTECH
            SELECT CUENTA_CUENTA_ID INTO CUENTA_1 FROM CUENTA_FINTECH WHERE CUENTA_CUENTA_ID = CUENTA_1;
            IF CUENTA_1 IS NULL THEN
                RAISE NO_CUENTA_FINTECH_EXCEPTION;
            END IF;
            
            -- SE COMPRUEBA QUE SEA SEGREGADA O POOLED
            SELECT CUENTA_FINTECH_ID INTO FINTECH FROM POOLED_ACCOUNT WHERE CUENTA_FINTECH_ID = CUENTA_1;
            IF FINTECH IS NULL THEN

                SELECT CUENTA_FINTECH_ID INTO FINTECH FROM SEGREGADA WHERE CUENTA_FINTECH_ID = CUENTA_1;
                IF FINTECH IS NULL THEN -- NO ES NI POOLED NI SEGREGADA -> EXCEPTION
                    RAISE NO_CUENTA_FINTECH_EXCEPTION;
                ELSE -- LA CUENTA FINTECH ES SEGREGADA

                    -- SE COMPRUEBA QUE LAS DIVISAS COINCIDAN Y SE GUARDA ID DE CUENTA_REFERENCIA
                    SELECT DIVISA_ABREVIATURA, CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA
                    JOIN SEGREGADA ON SEGREGADA.CUENTA_REF_ID = CUENTA_REFERENCIA.CUENTA_CUENTA_ID
                    WHERE SEGREGADA.CUENTA_FINTECH_ID = FINTECH
                    FOR UPDATE;

                    IF DIVISA_R <> P_DIVISA_ABREVIATURA THEN -- DIVISAS NO COINCIDEN -> EXCEPTION
                        RAISE SEGREGADA_DIVISA_NOT_MATCH;
                    END IF;

                    -- COMPROBAR SALDO SUFICIENTE
                    -- CUENTA_REFERENCIA SÃ? ES NECESARIO BLOQUEARLA YA QUE EL SALDO SE PODRÃ?A MODIFICAR DURANTE TRANSACCIÃ“N
                    SELECT SALDO INTO P_SALDO FROM CUENTA_REFERENCIA WHERE CUENTA_CUENTA_ID = REF_AUX FOR UPDATE;
                    IF SALDO < IMPORTE THEN
                        RAISE SALDO_INSUFICIENTE_EXCEPTION;
                    END IF;

                    -- REDUCIR SALDO
                    UPDATE CUENTA_REFERENCIA SET SALDO = SALDO - IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                END IF;
            ELSE -- LA CUENTA FINTECH ES POOLED

                -- SE BUSCA LA DIVISA DESEADA EN LA POOLED, SI NO SE ENCUENTRA SE CREA
                -- SE ASUME QUE SOLO EXISTE UNA CUENTA REFERENCIA POR DIVISA --
                SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                JOIN DEPOSITAR_EN D ON D.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                JOIN POOLED_ACCOUNT P ON P.CUENTA_FINTECH_ID = D.POOL_ID
                WHERE P.CUENTA_FINTECH_ID = FINTECH
                AND CR.DIVISA_ABREVIATURA LIKE P_DIVISA_ABREVIATURA;

                IF DIVISA_R IS NULL OR REF_AUX IS NULL THEN -- DIVISA NOT FOUND -> EXCEPTION
                    -- NO SE PUEDE CREAR UNA NUEVA CUENTA REFERENCIA YA QUE EL SALDO SERÃ?A 0
                    -- AQUÃ? LA CUENTA POOLED ES LA EMISORA DE LA TRANSACCIÃ“N LUEGO EL SALDO NO PUEDE SER 0
                    RAISE DIVISA_NOT_FOUND_EXCEPTION;
                ELSE -- CUENTA POOLED YA TIENE REF CON DIVISA DESEADA
                    -- SE COMPRUEBA SALDO SUFICIENTE
                    -- CUENTA_REFERENCIA SÃ? ES NECESARIO BLOQUEARLA YA QUE EL SALDO SE PODRÃ?A MODIFICAR DURANTE TRANSACCIÃ“N
                    SELECT SALDO INTO P_SALDO FROM CUENTA_REFERENCIA WHERE CUENTA_CUENTA_ID = REF_AUX FOR UPDATE;
                    IF SALDO < IMPORTE THEN
                        RAISE SALDO_INSUFICIENTE_EXCEPTION;
                    END IF;
                    --  REDUCIR SALDO
                    UPDATE CUENTA_REFERENCIA SET SALDO = SALDO - IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                    UPDATE DEPOSITAR_EN SET SALDO = SALDO - IMPORTE WHERE CUENTA_REF_ID = REF_AUX AND POOL_ID = FINTECH;
                END IF;

            END IF;

            -- CREAR CUENTA EXTERNA NO REGISTRADA
            CUENTA_2 := SQ_CUENTA.NEXTVAL;
            INSERT INTO CUENTA VALUES (CUENTA_2, IBAN_2, NULL); -- ID BY SEQUENCE SWIFT IS NULL

        ELSE -- TODAS LAS CUENTAS ESTÃ?N REGISTRADAS
            
             -- SE COMPRUEBA QUE ALGUNA CUENTA SEA FINTECH
            SELECT CUENTA_CUENTA_ID INTO CUENTA_1 FROM CUENTA_FINTECH WHERE CUENTA_CUENTA_ID = CUENTA_1;
            SELECT CUENTA_CUENTA_ID INTO CUENTA_2 FROM CUENTA_FINTECH WHERE CUENTA_CUENTA_ID = CUENTA_2;

            IF CUENTA_1 IS NULL AND CUENTA_2 IS NULL THEN -- NINGUNA CUENTA ES FINTECH -> EXCEPTION
                RAISE NO_CUENTA_FINTECH_EXCEPTION;
            ELSIF CUENTA_1 IS NULL THEN -- CUENTA_1 ES EXTERNA EN BD
            
                -- SE COMPRUEBA QUE SEA SEGREGADA O POOLED
                SELECT CUENTA_FINTECH_ID INTO FINTECH FROM POOLED_ACCOUNT WHERE CUENTA_FINTECH_ID = CUENTA_2;
                IF FINTECH IS NULL THEN

                    SELECT CUENTA_FINTECH_ID INTO FINTECH FROM SEGREGADA WHERE CUENTA_FINTECH_ID = CUENTA_2;
                    IF FINTECH IS NULL THEN -- NO ES NI POOLED NI SEGREGADA -> EXCEPTION
                        RAISE NO_CUENTA_FINTECH_EXCEPTION;
                    ELSE -- LA CUENTA FINTECH ES SEGREGADA

                        -- SE COMPRUEBA QUE LAS DIVISAS COINCIDAN Y SE GUARDA ID DE CUENTA_REFERENCIA
                        SELECT DIVISA_ABREVIATURA, CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA
                        JOIN SEGREGADA ON SEGREGADA.CUENTA_REF_ID = CUENTA_REFERENCIA.CUENTA_CUENTA_ID
                        WHERE SEGREGADA.CUENTA_FINTECH_ID = FINTECH
                        FOR UPDATE;

                        IF DIVISA_R <> P_DIVISA_ABREVIATURA2 THEN -- DIVISAS NO COINCIDEN -> EXCEPTION
                            RAISE SEGREGADA_DIVISA_NOT_MATCH;
                        END IF;

                        -- AUMENTAR SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO + IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                    END IF;
                ELSE -- LA CUENTA ES POOLED

                    -- SE BUSCA LA DIVISA DESEADA EN LA POOLED, SI NO SE ENCUENTRA SE CREA
                    SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                    JOIN DEPOSITAR_EN D ON D.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                    JOIN POOLED_ACCOUNT P ON P.CUENTA_FINTECH_ID = D.POOL_ID
                    WHERE P.CUENTA_FINTECH_ID = FINTECH
                    AND CR.DIVISA_ABREVIATURA LIKE P_DIVISA_ABREVIATURA2
                    FOR UPDATE;

                    IF DIVISA_R IS NULL OR REF_AUX IS NULL THEN -- DIVISA NOT FOUND -> CREAR CUENTA_REF CON DIVISA
                        REF_AUX := SQ_CUENTA.NEXTVAL;
                        -- ID BY SEQUENCE, BANCO: DEFAULT, SALDO INICIADO CON CANTIDAD DE TRANSACCION
                        INSERT INTO CUENTA_REFERENCIA VALUES (REF_AUX, 'DEFAULT', NULL, NULL, IMPORTE, SYSDATE, 'ACTIVO', P_DIVISA_ABREVIATURA2);
                        -- SE ASIGNA A LA CUENTA POOLED LA NUEVA CUENTA REFERENCIA CON EL SALDO DE LA TRANSACCION
                        INSERT INTO DEPOSITAR_EN VALUES (IMPORTE, REF_AUX, FINTECH);
                    ELSE -- CUENTA POOLED YA TIENE REF CON DIVISA DESEADA
                        -- AGREGAR TRANSACCION A SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO + IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                        UPDATE DEPOSITAR_EN SET SALDO = SALDO + IMPORTE WHERE CUENTA_REF_ID = REF_AUX AND POOL_ID = FINTECH;
                    END IF;

                END IF;
            ELSIF CUENTA_2 IS NULL THEN -- CUENTA_2 ES EXTERNA EN BD

                -- SE COMPRUEBA QUE LA OTRA CUENTA SEA FINTECH
                SELECT CUENTA_CUENTA_ID INTO CUENTA_1 FROM CUENTA_FINTECH WHERE CUENTA_CUENTA_ID = CUENTA_1;
                IF CUENTA_1 IS NULL THEN
                    RAISE NO_CUENTA_FINTECH_EXCEPTION;
                END IF;
                
                -- SE COMPRUEBA QUE SEA SEGREGADA O POOLED
                SELECT CUENTA_FINTECH_ID INTO FINTECH FROM POOLED_ACCOUNT WHERE CUENTA_FINTECH_ID = CUENTA_1;
                IF FINTECH IS NULL THEN

                    SELECT CUENTA_FINTECH_ID INTO FINTECH FROM SEGREGADA WHERE CUENTA_FINTECH_ID = CUENTA_1;
                    IF FINTECH IS NULL THEN -- NO ES NI POOLED NI SEGREGADA -> EXCEPTION
                        RAISE NO_CUENTA_FINTECH_EXCEPTION;
                    ELSE -- LA CUENTA FINTECH ES SEGREGADA

                        -- SE COMPRUEBA QUE LAS DIVISAS COINCIDAN Y SE GUARDA ID DE CUENTA_REFERENCIA
                        SELECT DIVISA_ABREVIATURA, CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA
                        JOIN SEGREGADA ON SEGREGADA.CUENTA_REF_ID = CUENTA_REFERENCIA.CUENTA_CUENTA_ID
                        WHERE SEGREGADA.CUENTA_FINTECH_ID = FINTECH;

                        IF DIVISA_R <> P_DIVISA_ABREVIATURA THEN -- DIVISAS NO COINCIDEN -> EXCEPTION
                            RAISE SEGREGADA_DIVISA_NOT_MATCH;
                        END IF;

                        -- COMPROBAR SALDO SUFICIENTE
                        -- CUENTA_REFERENCIA SÃ? ES NECESARIO BLOQUEARLA YA QUE EL SALDO SE PODRÃ?A MODIFICAR DURANTE TRANSACCIÃ“N
                        SELECT SALDO INTO P_SALDO FROM CUENTA_REFERENCIA WHERE CUENTA_CUENTA_ID = REF_AUX FOR UPDATE;
                        IF SALDO < IMPORTE THEN
                            RAISE SALDO_INSUFICIENTE_EXCEPTION;
                        END IF;

                        -- REDUCIR SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO - IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                    END IF;
                ELSE -- LA CUENTA FINTECH ES POOLED

                    -- SE BUSCA LA DIVISA DESEADA EN LA POOLED, SI NO SE ENCUENTRA SE CREA
                    -- SE ASUME QUE SOLO EXISTE UNA CUENTA REFERENCIA POR DIVISA --
                    SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                    JOIN DEPOSITAR_EN D ON D.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                    JOIN POOLED_ACCOUNT P ON P.CUENTA_FINTECH_ID = D.POOL_ID
                    WHERE P.CUENTA_FINTECH_ID = FINTECH
                    AND CR.DIVISA_ABREVIATURA LIKE P_DIVISA_ABREVIATURA
                    FOR UPDATE;

                    IF DIVISA_R IS NULL OR REF_AUX IS NULL THEN -- DIVISA NOT FOUND -> EXCEPTION
                        -- NO SE PUEDE CREAR UNA NUEVA CUENTA REFERENCIA YA QUE EL SALDO SERÃ?A 0
                        -- AQUÃ? LA CUENTA POOLED ES LA EMISORA DE LA TRANSACCIÃ“N LUEGO EL SALDO NO PUEDE SER 0
                        RAISE DIVISA_NOT_FOUND_EXCEPTION;
                    ELSE -- CUENTA POOLED YA TIENE REF CON DIVISA DESEADA
                        -- SE COMPRUEBA SALDO SUFICIENTE
                        -- CUENTA_REFERENCIA SÃ? ES NECESARIO BLOQUEARLA YA QUE EL SALDO SE PODRÃ?A MODIFICAR DURANTE TRANSACCIÃ“N
                        SELECT SALDO INTO P_SALDO FROM CUENTA_REFERENCIA WHERE CUENTA_CUENTA_ID = REF_AUX FOR UPDATE;
                        IF SALDO < IMPORTE THEN
                            RAISE SALDO_INSUFICIENTE_EXCEPTION;
                        END IF;
                        --  REDUCIR SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO - IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                        UPDATE DEPOSITAR_EN SET SALDO = SALDO - IMPORTE WHERE CUENTA_REF_ID = REF_AUX AND POOL_ID = FINTECH;
                    END IF;

                END IF;

            ELSE -- NINGUNA CUENTA ES EXTERNA
                
                -- CUENTA_1
                -- SE COMPRUEBA QUE SEA SEGREGADA O POOLED
                SELECT CUENTA_FINTECH_ID INTO FINTECH FROM POOLED_ACCOUNT WHERE CUENTA_FINTECH_ID = CUENTA_1;
                IF FINTECH IS NULL THEN

                    SELECT CUENTA_FINTECH_ID INTO FINTECH FROM SEGREGADA WHERE CUENTA_FINTECH_ID = CUENTA_1;
                    IF FINTECH IS NULL THEN -- NO ES NI POOLED NI SEGREGADA -> EXCEPTION
                        RAISE NO_CUENTA_FINTECH_EXCEPTION;
                    ELSE -- LA CUENTA FINTECH ES SEGREGADA

                        -- SE COMPRUEBA QUE LAS DIVISAS COINCIDAN Y SE GUARDA ID DE CUENTA_REFERENCIA
                        SELECT DIVISA_ABREVIATURA, CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA
                        JOIN SEGREGADA ON SEGREGADA.CUENTA_REF_ID = CUENTA_REFERENCIA.CUENTA_CUENTA_ID
                        WHERE SEGREGADA.CUENTA_FINTECH_ID = FINTECH;

                        IF DIVISA_R <> P_DIVISA_ABREVIATURA THEN -- DIVISAS NO COINCIDEN -> EXCEPTION
                            RAISE SEGREGADA_DIVISA_NOT_MATCH;
                        END IF;

                        -- COMPROBAR SALDO SUFICIENTE
                        -- CUENTA_REFERENCIA SÃ? ES NECESARIO BLOQUEARLA YA QUE EL SALDO SE PODRÃ?A MODIFICAR DURANTE TRANSACCIÃ“N
                        SELECT SALDO INTO P_SALDO FROM CUENTA_REFERENCIA WHERE CUENTA_CUENTA_ID = REF_AUX FOR UPDATE;
                        IF SALDO < IMPORTE THEN
                            RAISE SALDO_INSUFICIENTE_EXCEPTION;
                        END IF;

                        -- REDUCIR SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO - IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                    END IF;
                ELSE -- LA CUENTA FINTECH ES POOLED

                    -- SE BUSCA LA DIVISA DESEADA EN LA POOLED, SI NO SE ENCUENTRA SE CREA
                    -- SE ASUME QUE SOLO EXISTE UNA CUENTA REFERENCIA POR DIVISA --
                    SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                    JOIN DEPOSITAR_EN D ON D.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                    JOIN POOLED_ACCOUNT P ON P.CUENTA_FINTECH_ID = D.POOL_ID
                    WHERE P.CUENTA_FINTECH_ID = FINTECH
                    AND CR.DIVISA_ABREVIATURA LIKE P_DIVISA_ABREVIATURA
                    FOR UPDATE;

                    IF DIVISA_R IS NULL OR REF_AUX IS NULL THEN -- DIVISA NOT FOUND -> EXCEPTION
                        -- NO SE PUEDE CREAR UNA NUEVA CUENTA REFERENCIA YA QUE EL SALDO SERÃ?A 0
                        -- AQUÃ? LA CUENTA POOLED ES LA EMISORA DE LA TRANSACCIÃ“N LUEGO EL SALDO NO PUEDE SER 0
                        RAISE DIVISA_NOT_FOUND_EXCEPTION;
                    ELSE -- CUENTA POOLED YA TIENE REF CON DIVISA DESEADA
                        -- SE COMPRUEBA SALDO SUFICIENTE
                        -- CUENTA_REFERENCIA SÃ? ES NECESARIO BLOQUEARLA YA QUE EL SALDO SE PODRÃ?A MODIFICAR DURANTE TRANSACCIÃ“N
                        SELECT SALDO INTO P_SALDO FROM CUENTA_REFERENCIA WHERE CUENTA_CUENTA_ID = REF_AUX FOR UPDATE;
                        IF SALDO < IMPORTE THEN
                            RAISE SALDO_INSUFICIENTE_EXCEPTION;
                        END IF;
                        --  REDUCIR SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO - IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                        UPDATE DEPOSITAR_EN SET SALDO = SALDO - IMPORTE WHERE CUENTA_REF_ID = REF_AUX AND POOL_ID = FINTECH;
                    END IF;
                END IF;

                -- CUENTA_2
                -- SE COMPRUEBA QUE SEA SEGREGADA O POOLED
                SELECT CUENTA_FINTECH_ID INTO FINTECH FROM POOLED_ACCOUNT WHERE CUENTA_FINTECH_ID = CUENTA_2;
                IF FINTECH IS NULL THEN

                    SELECT CUENTA_FINTECH_ID INTO FINTECH FROM SEGREGADA WHERE CUENTA_FINTECH_ID = CUENTA_2;
                    IF FINTECH IS NULL THEN -- NO ES NI POOLED NI SEGREGADA -> EXCEPTION
                        RAISE NO_CUENTA_FINTECH_EXCEPTION;
                    ELSE -- LA CUENTA FINTECH ES SEGREGADA

                        -- SE COMPRUEBA QUE LAS DIVISAS COINCIDAN Y SE GUARDA ID DE CUENTA_REFERENCIA
                        SELECT DIVISA_ABREVIATURA, CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA
                        JOIN SEGREGADA ON SEGREGADA.CUENTA_REF_ID = CUENTA_REFERENCIA.CUENTA_CUENTA_ID
                        WHERE SEGREGADA.CUENTA_FINTECH_ID = FINTECH
                        FOR UPDATE;

                        IF DIVISA_R <> P_DIVISA_ABREVIATURA2 THEN -- DIVISAS NO COINCIDEN -> EXCEPTION
                            RAISE SEGREGADA_DIVISA_NOT_MATCH;
                        END IF;

                        -- AUMENTAR SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO + IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                    END IF;
                ELSE -- LA CUENTA ES POOLED

                    -- SE BUSCA LA DIVISA DESEADA EN LA POOLED, SI NO SE ENCUENTRA SE CREA
                    SELECT CR.DIVISA_ABREVIATURA, CR.CUENTA_CUENTA_ID INTO DIVISA_R, REF_AUX FROM CUENTA_REFERENCIA CR
                    JOIN DEPOSITAR_EN D ON D.CUENTA_REF_ID = CR.CUENTA_CUENTA_ID
                    JOIN POOLED_ACCOUNT P ON P.CUENTA_FINTECH_ID = D.POOL_ID
                    WHERE P.CUENTA_FINTECH_ID = FINTECH
                    AND CR.DIVISA_ABREVIATURA LIKE P_DIVISA_ABREVIATURA2
                    FOR UPDATE;

                    IF DIVISA_R IS NULL OR REF_AUX IS NULL THEN -- DIVISA NOT FOUND -> CREAR CUENTA_REF CON DIVISA
                        REF_AUX := SQ_CUENTA.NEXTVAL;
                        -- ID BY SEQUENCE, BANCO: DEFAULT, SALDO INICIADO CON CANTIDAD DE TRANSACCION
                        INSERT INTO CUENTA_REFERENCIA VALUES (REF_AUX, 'DEFAULT', NULL, NULL, IMPORTE, SYSDATE, 'ACTIVO', P_DIVISA_ABREVIATURA2);
                        -- SE ASIGNA A LA CUENTA POOLED LA NUEVA CUENTA REFERENCIA CON EL SALDO DE LA TRANSACCION
                        INSERT INTO DEPOSITAR_EN VALUES (IMPORTE, REF_AUX, FINTECH);
                    ELSE -- CUENTA POOLED YA TIENE REF CON DIVISA DESEADA
                        -- AGREGAR TRANSACCION A SALDO
                        UPDATE CUENTA_REFERENCIA SET SALDO = SALDO + IMPORTE WHERE CUENTA_CUENTA_ID = REF_AUX;
                        UPDATE DEPOSITAR_EN SET SALDO = SALDO + IMPORTE WHERE CUENTA_REF_ID = REF_AUX AND POOL_ID = FINTECH;
                    END IF;

                END IF;

            END IF;

        END IF;

        -- CREAR TRANSACCION
        INSERT INTO TRANSACCION VALUES (1, P_FECHA_INSTRUCCION, P_CANTIDAD, SYSDATE, P_TIPO, P_COMISION, 
            P_INTERNACIONAL, P_DIVISA_ABREVIATURA, P_DIVISA_ABREVIATURA2, CUENTA_1, CUENTA_2);

        -- COMMIT
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK;
                RAISE;
    END; 
    
    PROCEDURE CAMBIO_DIVISAS(
    P_IBAN              IN CUENTA.IBAN%TYPE,
    P_CANTIDAD          IN TRANSACCION.CANTIDAD%TYPE
    P_DIVISA_ORIGEN     IN DIVISA.ABREVIATURA%TYPE,
    P_DIVISA_OBJETIVO   IN DIVISA.ABREVIATURA%TYPE
    )
    IS
    -- VARIABLES
    CUENTA_AUX POOLED_ACCOUNT.CUENTA_FINTECH_ID%TYPE;
    DIVISA_AUX DIVISA.ABREVIATURA%TYPE;
    BEGIN
        SELECT CUENTA_FINTECH_ID INTO CUENTA_AUX FROM POOLED_ACCOUNT WHERE IBAN LIKE P_IBAN;
        IF CUENTA IS NULL THEN -- CUENTA NO SE ENCUENTRA EN BD -> EXCEPTION
            RAISE CUENTA_NOT_FOUND_EXCEPTION;
        END IF;
        SELECT ABREVIATURA INTO DIVISA_AUX FROM DIVISA WHERE ABREVIATURA = P_DIVISA_ORIGEN;
        IF DIVISA_AUX IS NULL THEN -- DIVISA NO SE ENCUENTRA EN BD -> EXCEPTION
            RAISE DIVISA_NOT_FOUND_EXCEPTION;
        END IF;
        SELECT ABREVIATURA INTO DIVISA_AUX FROM DIVISA WHERE ABREVIATURA = P_DIVISA_OBJETIVO;
        IF DIVISA_AUX IS NULL THEN -- DIVISA NO SE ENCUENTRA EN BD -> EXCEPTION
            RAISE DIVISA_NOT_FOUND_EXCEPTION;
        END IF;

        PK_OPERATIVA.INSERTAR_TRANSACCIONES(SYSDATE, P_CANTIDAD, 'CAMBIO DIVISAS', 0, TRUE, P_DIVISA_ORIGEN, P_DIVISA_OBJETIVO, P_IBAN, P_IBAN);

        -- COMMIT
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK;
                RAISE;
    END;

END PK_OPERATIVA;